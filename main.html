<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>CG-Project Stormtrooper</title>
	</head>

	<body>
		<script src="http://code.jquery.com/jquery-2.1.3.min.js"></script>
		<script src="js/three.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/MTLLoader.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script src="js/THREEx.KeyboardState.js"></script>

		<script id="fs_Sun" type="x-shader/x-fragment">
			uniform float time;
			uniform vec2 resolution;

			uniform float fogDensity;
			uniform vec3 fogColor;

			uniform sampler2D texture1;
			uniform sampler2D texture2;

			varying vec2 vUv;

			void main( void ) {

				vec2 position = -1.0 + 4.0 * vUv;

				vec4 noise = texture2D( texture1, vUv );
				vec2 T1 = vUv + vec2( 1.5, -1.5 ) * time  *0.02;
				vec2 T2 = vUv + vec2( -0.5, 2.0 ) * time * 0.01;

				T1.x += noise.x * 2.0;
				T1.y += noise.y * 2.0;
				T2.x -= noise.y * 0.2;
				T2.y += noise.z * 0.2;

				float p = texture2D( texture1, T1 * 3.0 ).a;

				vec4 color = texture2D( texture2, T2 * 2.0 );
				vec4 temp = color * ( vec4( p, p, p, p ) * 2.0 ) + ( color * color - 0.1 );

				if( temp.r > 1.0 ){ temp.bg += clamp( temp.r - 2.0, 0.0, 100.0 ); }
				if( temp.g > 1.0 ){ temp.rb += temp.g - 1.0; }
				if( temp.b > 1.0 ){ temp.rg += temp.b - 1.0; }

				gl_FragColor = temp;

				float depth = gl_FragCoord.z / gl_FragCoord.w;
				const float LOG2 = 1.442695;
				float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );
				fogFactor = 1.0 - clamp( 1.0 , 0.0, 1.0 );

				gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

			}

		</script>

		<script id="vs_Sun" type="x-shader/x-vertex">
			uniform vec2 uvScale;
			varying vec2 vUv;

			void main()
			{

				vUv = uvScale * uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;

			}
		</script>

		<script>
			var cameraRotate, cameraTop, cameraFurther, cameraSide, cameraArc, scene, renderer;
			var plane;
			var container;
			var clock = new THREE.Clock();
			var uniforms;			
			var atualCamera = 0;
			var velocity = 0.05; // set general rotation velocity
			var keyboard = new THREEx.KeyboardState();

			objs = {};
			curve_counter = 0;
			curve_index = 0;

			if (Detector.webgl) {
    			init();
    			loadObjs();
    			animate();
			} else {
			    var warning = Detector.getWebGLErrorMessage();
			    document.getElementById('container').appendChild(warning);
			}
			
			function init(){
				container = document.createElement('div');
				document.body.appendChild(container);


				//Scene
				scene = new THREE.Scene();

				containerBB8 = new THREE.Object3D();
				scene.add(containerBB8);

				//Renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFShadowMap;  // options are THREE.BasicShadowMap | THREE.PCFShadowMap | THREE.PCFSoftShadowMap
				container.appendChild( renderer.domElement );

				//Planet ground
				planetRadius = 100; //set main planet radius
				var loader = new THREE.TextureLoader();
				var groundTexture = loader.load( 'Textures/grasslight-big.jpg' );
				groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
				groundTexture.repeat.set( 1500, 1500);
				groundTexture.anisotropy = 16;
				var groundMaterial = new THREE.MeshPhongMaterial( { color: 0x909090, specular: 0x111111, map: groundTexture } );
				var meshPlanet = new THREE.Mesh( new THREE.SphereGeometry( planetRadius, 64, 32 ), groundMaterial );
				meshPlanet.receiveShadow = true;
				meshPlanet.castShadow = true;
				scene.add( meshPlanet );



				//ambient light
				var ambient = new THREE.AmbientLight(0xffffff);
				scene.add( ambient );

				//spotLight - Sun
				spotLight = new THREE.SpotLight( 0xffffff, 2 );
				spotLight.position.set(0, 0, 500);
				//Shadows
				spotLight.castShadow = true;
				spotLight.penumbra = 0.05;
				spotLight.decay = 0.8;
				spotLight.distance = 500;
				spotLight.shadow.mapSize.width = 1024*4;
				spotLight.shadow.mapSize.height = 1024*4;
				spotLight.shadow.camera.near = 1;
				spotLight.shadow.camera.far = 500;
				scene.add(spotLight);

				// Sun sphere
				var textureLoader = new THREE.TextureLoader();

				uniforms = {
					fogColor:   { value: new THREE.Vector3( 0, 0, 0 ) },
					time:       { value: 1.0 },
					resolution: { value: new THREE.Vector2() },
					uvScale:    { value: new THREE.Vector2( 3.0, 1.0 ) },
					texture1:   { value: textureLoader.load( "Textures/cloud.png" ) },
					texture2:   { value: textureLoader.load( "Textures/lavatile.jpg" ) }

				};
				uniforms.texture1.value.wrapS = uniforms.texture1.value.wrapT = THREE.RepeatWrapping;
				uniforms.texture2.value.wrapS = uniforms.texture2.value.wrapT = THREE.RepeatWrapping;

				var material = new THREE.ShaderMaterial( {

					uniforms: uniforms,
					vertexShader: document.getElementById( 'vs_Sun' ).textContent,
					fragmentShader: document.getElementById( 'fs_Sun' ).textContent

				} );

				var sphere = new THREE.SphereGeometry( 10, 16, 8 );
				meshSun = new THREE.Mesh( sphere, material );
				spotLight.add( meshSun );

				// BezierCurve
				// Define common base coordenates
				P = [2*planetRadius/3, planetRadius+3]

				// Define control points
				CP = [
					new THREE.Vector3(-P[0],-P[0],P[1]), new THREE.Vector3(-P[0],P[0],P[1]), new THREE.Vector3(P[0],-P[0],P[1]), new THREE.Vector3( P[0],P[0],P[1]),
					new THREE.Vector3(-P[0],P[1],P[0]), new THREE.Vector3(-P[0],P[1],-P[0]), new THREE.Vector3(P[0],P[1],P[0]), new THREE.Vector3(P[0],P[1],-P[0]), 
					new THREE.Vector3(-P[0],P[0],-P[1]), new THREE.Vector3(-P[0],-P[0],-P[1]), new THREE.Vector3(P[0],P[0],-P[1]), new THREE.Vector3(P[0],-P[0],-P[1]), 
					new THREE.Vector3(-P[0],-P[1],-P[0]), new THREE.Vector3(-P[0],-P[1],P[0]), new THREE.Vector3(P[0],-P[1],-P[0]), new THREE.Vector3(P[0],-P[1],P[0])
				];			

				// Draw curves
				curves = [
					new THREE.CubicBezierCurve3(CP[0], CP[1], CP[2], CP[3]),
					new THREE.CubicBezierCurve3(CP[3], CP[6], CP[1], CP[4]),
					new THREE.CubicBezierCurve3(CP[4], CP[5], CP[6], CP[7]),
					new THREE.CubicBezierCurve3(CP[7], CP[10], CP[5], CP[8]),
					new THREE.CubicBezierCurve3(CP[8], CP[9], CP[10], CP[11]),
					new THREE.CubicBezierCurve3(CP[11], CP[14], CP[9], CP[12]),
					new THREE.CubicBezierCurve3(CP[12], CP[13], CP[14], CP[15]),
					new THREE.CubicBezierCurve3(CP[15], CP[2], CP[13], CP[0])
				];
					

				//Rotating Camera
				cameraRotate = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 + planetRadius * 2 );
				cameraRotate.position.set(0, -10, 3 + planetRadius);				

				//Top Camera
				cameraTop = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 + planetRadius * 2);
				cameraTop.position.set(0, 0, 150+planetRadius);				

				//Further Camera
				cameraFurther = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 + planetRadius * 2);
				cameraFurther.position.set(0, -(100+planetRadius), 3+planetRadius);

				//Side Camera
				cameraSide = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 + planetRadius * 2);
				cameraSide.position.set(-(100+planetRadius)-100, 0, 0);

				//Camera Arc
				cameraArc = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 + planetRadius * 2);

				//Camera BB8
				cameraBB8 = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 + planetRadius * 2);
				cameraBB8.position.set(2, 0.5, planetRadius+3);
				containerBB8.add(cameraBB8);

				controls = new THREE.TrackballControls( cameraTop );

				controls.rotateSpeed = 2.0;
				controls.zoomSpeed = 2.0;
				controls.panSpeed = 2.0;

				controls.staticMoving = true;

				controls.target.set(3, 0, 1+planetRadius)

				window.addEventListener( 'resize', onWindowResize, false );				
				window.addEventListener( 'keydown', keyManager );

				

			}

			function loadObjs() {	
				$.ajax({
				    type: "GET",
				    url: "Config/Models.xml",
				    dataType: "xml",
				    async: false,
				    cache: false,	
				    success: function (xml) {			       			    	
				        $(xml).find("Model").each(function() {
				        	var name = $(this).find('Name').text();	
				        	var scaPath = $(this).find('Scale');    	
				        	var posPath = $(this).find('Position');				        	
				        	var rotPath = $(this).find('Rotation');
				        	var x, y, z;

				        	var mtlL = new THREE.MTLLoader();
				        	mtlL.setPath('3DModels/'+name+'/');						
							mtlL.load(name+'.mtl', function( materials ){
								materials.preload();
				        		loader = new THREE.OBJLoader();
				        		loader.setMaterials(materials);
			        			loader.setPath('3DModels/'+name+'/');
			        			loader.load(name+'.obj', function ( object ) {
				        			object.castShadow = true;
				        			object.receiveShadow = true;
				        			object.name = name;

				        			// Scale
			        				x = parseFloat(scaPath.find('x').text());
			        				y = parseFloat(scaPath.find('y').text());
			        				z = parseFloat(scaPath.find('z').text());
			        				object.scale.set(x,y,z);

			        				// Position
			        				x = parseFloat(posPath.find('x').text());
			        				y = parseFloat(posPath.find('y').text());
			        				z = parseFloat(posPath.find('z').text());
			        				object.position.set(x,y,z+planetRadius);

			        				// Rotation
			        				x = parseFloat(rotPath.find('x').text());
			        				y = parseFloat(rotPath.find('y').text());
			        				z = parseFloat(rotPath.find('z').text());
			        				object.rotation.set(x,y,z);

			        				//shadow
			        				object.traverse( function ( child ) {
									    if ( child instanceof THREE.Mesh ) {
									        child.castShadow = true;
									        child.receiveShadow = true;
									    }
									} );
			        				scene.add(object);
			        				if(object.name.localeCompare("BB8")){
					        			containerBB8.add(objs["BB8"]);
				        			}
			        				objs[object.name] = object;
			        			});				        	
				        	});
				        });
				    }
				});
			}

			function onWindowResize() {

				cameraRotate.aspect = window.innerWidth / window.innerHeight;
				cameraRotate.updateProjectionMatrix();
				cameraFurther.aspect = window.innerWidth / window.innerHeight;
				cameraFurther.updateProjectionMatrix();
				cameraTop.aspect = window.innerWidth / window.innerHeight;
				cameraTop.updateProjectionMatrix();
				cameraSide.aspect = window.innerWidth / window.innerHeight;
				cameraSide.updateProjectionMatrix();
				cameraArc.aspect = window.innerWidth / window.innerHeight;
				cameraArc.updateProjectionMatrix();
				cameraBB8.aspect = window.innerWidth / window.innerHeight;
				cameraBB8.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}					

			function animate() {												
				requestAnimationFrame( animate );
				controls.update();			
				render();
			}

			function keyManager(event){
				if(event.keyCode == 32)
					atualCamera = (atualCamera + 1) % 6;					
			}
			
			function render() {										
				var delta = clock.getDelta();
				var eTime = clock.getElapsedTime();

				var walkVel = 0.08
				var turnVel = 1.5
				var moveDistance = 1 * delta;

				if ( keyboard.pressed("W") ){
					containerBB8.rotateY(-moveDistance*walkVel);
				}
				if ( keyboard.pressed("S") ){
					containerBB8.rotateY(moveDistance*walkVel);
				}
				if ( keyboard.pressed("A") ){
					containerBB8.rotateX(moveDistance*walkVel);
				}
				if ( keyboard.pressed("D") ){
					containerBB8.rotateX(-moveDistance*walkVel);
				}
				if ( keyboard.pressed("Q")){
					containerBB8.rotateZ(moveDistance*turnVel);
				}
				if ( keyboard.pressed("E")){
					containerBB8.rotateZ(-moveDistance*turnVel);
				}
				
				//[Stormtrooper]
				objs["StormtrooperEP7"].rotation.y += 0.03;		

				//Naboo rotation
				var angle = 0.25 //sets naboo rotation off of the spotlight rotation plane by arctan(angle)
				var angleVariation = Math.cos(velocity * eTime * 0.1); //sets Naboo rotation plane variation overtime
				objs["Naboo"].position.x = scene.position.x + (80+planetRadius) * Math.cos(velocity * eTime) * angle * angleVariation;
				objs["Naboo"].position.y = scene.position.y + (80+planetRadius) * Math.cos(velocity * eTime);
				objs["Naboo"].position.z = scene.position.z + (80+planetRadius) * Math.sin(velocity * eTime);	

				//Arc170				
				var t = curves[curve_index].getUtoTmapping(curve_counter / 100);
				objs["Arc170"].position.set(curves[curve_index].getPointAt(t).x, curves[curve_index].getPointAt(t).y, curves[curve_index].getPointAt(t).z);    	

				if (curve_index == 0) {
    				objs["Arc170"].up.set(0,0,1);
    			} else if (curve_index == 1) {
    				objs["Arc170"].up.set(0,0.5,0.5);
    			} else if (curve_index == 2) {
    				objs["Arc170"].up.set(0,1,0);
    			} else if (curve_index == 3) {
    				objs["Arc170"].up.set(0,0.5,-0.5);
    			} else if (curve_index == 4) {
    				objs["Arc170"].up.set(0,0,-1);
    			} else if (curve_index == 5) {
    				objs["Arc170"].up.set(0,-0.5,-0.5);
    			} else if (curve_index == 6) {
    				objs["Arc170"].up.set(0,-1,0);
    			} else if (curve_index == 7) {
    				objs["Arc170"].up.set(0,-0.5,0.5);
    			}
    		
    			objs["Arc170"].lookAt(curves[curve_index].getPointAt(curves[curve_index].getUtoTmapping((curve_counter+0.5) / 100)));    			    			
    			curve_counter += 0.5;
    			if (curve_counter == 100) {
    				curve_counter = 0;
    				curve_index = (curve_index + 1) % 8;
    			}

				spotLight.position.y = scene.position.y + (planetRadius + 150) * Math.cos(velocity * eTime * 27.3 * 0.1);
				spotLight.position.z = scene.position.z + (planetRadius + 150) * Math.sin(velocity * eTime * 27.3 * 0.1	);
				uniforms.time.value += 2*delta;
				spotLight.lookAt(scene.position);


				var X = scene.position.x + 20 * Math.cos(0.5 * eTime); 						
				var Y = scene.position.y + 20 * Math.sin(0.5 * eTime);				

				var m4 = new THREE.Matrix4;		
				m4.set(	0, 0, 0, X, 
						0, 0, 0, Y, 
						0, 0, 1, 0, 
						0, 0, 0, 1);				
				
				cameraRotate.position.applyMatrix4(m4);
				cameraRotate.up.set(0, 0, 1);
				cameraRotate.lookAt(new THREE.Vector3(scene.position.x, scene.position.y, planetRadius));	

				cameraTop.up.set(0, 0, 1);

				cameraFurther.up.set(0, 0, 1);
				cameraFurther.lookAt(scene.position);

				cameraSide.up.set(0, 0, 1);
				cameraSide.lookAt(scene.position);

				cameraArc.up.copy(objs["Arc170"].up);
				cameraArc.lookAt(curves[curve_index].getPointAt(curves[curve_index].getUtoTmapping((curve_counter+0.5) / 100))); 
				cameraArc.position.copy(objs["Arc170"].position);

				cameraBB8.up.set(0, 0, 1);
				cameraBB8.lookAt(new THREE.Vector3(-3, 0, planetRadius+1));


				if (atualCamera == 0){
					renderer.render( scene, cameraRotate );
				} else if (atualCamera == 1){
					renderer.render( scene, cameraTop );
				} else if (atualCamera == 2){
					renderer.render( scene, cameraFurther);
				} else if (atualCamera == 3){
					renderer.render( scene, cameraSide);
				} else if (atualCamera == 4){
					renderer.render( scene, cameraArc );
				} else if (atualCamera == 5){
					renderer.render( scene, cameraBB8 );
				}		
			}

		</script>
	</body>
</html>