<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>CG-Project Stormtrooper</title>
	</head>

	<body>
		<script src="http://code.jquery.com/jquery-2.1.3.min.js"></script>
		<script src="js/three.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/MTLLoader.js"></script>
		<script src="js/Detector.js"></script>

		<script id="vs_BB8" type="x-shader/x-vertex">
		    varying vec2 vUv;
			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

		<script id="fs_BB8" type="x-shader/x-fragment">
	        uniform float time;
			uniform vec2 resolution;
			varying vec2 vUv;
			void main( void ) {
				vec2 position = -1.0 + 2.0 * vUv;
				float red = abs( sin( position.x * position.y + time / 5.0 ) );
				float green = abs( sin( position.x * position.y + time / 4.0 ) );
				float blue = abs( sin( position.x * position.y + time / 3.0 ) );
				gl_FragColor = vec4( red, green, blue, 1.0 );
			}
    	</script>

		<script>
			var rotatingCamera, topCamera, furtherCamera, scene, renderer;
			var plane;
			var container;
			var clock = new THREE.Clock();
			var uniforms;			
			var atualCamera = 0;	
			objs = [];
			velocity = 0.05;

			if (Detector.webgl) {
    			init();
    			loadObjs();
    			animate();
			} else {
			    var warning = Detector.getWebGLErrorMessage();
			    document.getElementById('container').appendChild(warning);
			}
			
			function init(){
				container = document.createElement('div');
				document.body.appendChild(container);

				//Rotating Camera
				rotatingCamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				rotatingCamera.position.set(0, -10, 3);

				//Top Camera
				topCamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				topCamera.position.set(0, 4, 20);

				//Further Camera
				furtherCamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				furtherCamera.position.set(0, -100, 3);

				//Scene
				scene = new THREE.Scene();

				//Renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFShadowMap;  // options are THREE.BasicShadowMap | THREE.PCFShadowMap | THREE.PCFSoftShadowMap
				container.appendChild( renderer.domElement );

				//Grass ground
				var textureLoader = new THREE.TextureLoader();
				var groundTexture = textureLoader.load( 'Textures/grasslight-big.jpg' );
				groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
				groundTexture.repeat.set( 1500, 1500);
				groundTexture.anisotropy = 16;
				var groundMaterial = new THREE.MeshPhongMaterial( { color: 0x909090, specular: 0x111111, map: groundTexture } );
				var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 20000, 20000 ), groundMaterial );
				mesh.receiveShadow = true;
				mesh.castShadow = true;
				scene.add( mesh );

				//ambient light
				var ambient = new THREE.AmbientLight(0x101010);
				scene.add( ambient );

				//spotLight - Sun
				spotLight = new THREE.SpotLight( 0xffffff, 3 );
				spotLight.position.set(0, 0, 0);
				//Shadows
				spotLight.castShadow = true;
				spotLight.penumbra = 0.05;
				spotLight.decay = 2;
				spotLight.distance = 300;
				spotLight.shadow.mapSize.width = 1024*4;
				spotLight.shadow.mapSize.height = 1024*4;
				spotLight.shadow.camera.near = 1;
				spotLight.shadow.camera.far = 300;
				scene.add(spotLight);

				//Sun sphere
				var sphere = new THREE.SphereGeometry( 10, 16, 8 );
				spotLight.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xfff16c } ) ) );;

				//Adds lensFlare

				// var textureFlare0 = textureLoader.load( "Textures/lensflare/lensflare0.png" );
				// var textureFlare2 = textureLoader.load( "Textures/lensflare/lensflare2.png" );
				// var textureFlare3 = textureLoader.load( "Textures/lensflare/lensflare3.png" );
				// lensFlare = new THREE.LensFlare( textureFlare0, 1024, 0.0);

				// lensFlare.add( textureFlare2, 512, 0.0 );
				// lensFlare.add( textureFlare2, 512, 0.0 );
				// lensFlare.add( textureFlare2, 512, 0.0 );

				// lensFlare.add( textureFlare3, 64, 0.6 );
				// lensFlare.add( textureFlare3, 64, 0.7 );
				// lensFlare.add( textureFlare3, 128, 0.9 );
				// lensFlare.add( textureFlare3, 64, 1.0 );
				// lensFlare.customUpdateCallback = lensFlareUpdateCallback;
				// lensFlare.position.set(0, 0, 1);
				// scene.add( lensFlare );


				/*
				// Used in shaders
				uniforms1 = {
					time:       { value: 1.0 },
					resolution: { value: new THREE.Vector2() }
				};			
				
				//obj file - load BB8
				loader = new THREE.OBJLoader(); 
				loader.load('3DModels/BB8/BB8.obj',	function ( object ) {

						var bb8Material = new THREE.ShaderMaterial({								
							uniforms : uniforms1,
				   			vertexShader: document.getElementById('vs_BB8').innerHTML,
				   			fragmentShader: document.getElementById('fs_BB8').innerHTML
						});	

						object.traverse( function ( child ) {
				        	if ( child instanceof THREE.Mesh ) {				        		
				            	child.material = bb8Material;
				        	}				        	
				    	});
			  						  		
				  		object.scale.set(0.01, 0.01, 0.01);
				  		object.position.set(-3, 0, 0);
				  		object.rotation.x = -80;
			      		scene.add( object );
			      		obj_bb8 = object;
				});*/			
				
				window.addEventListener( 'resize', onWindowResize, false );				
				window.addEventListener( 'keydown', keyManager );

				

			}

			function loadObjs() {	
				$.ajax({
				    type: "GET",
				    url: "Config/Models.xml",
				    dataType: "xml",
				    cache: false,
				    async: false,
				    success: function (xml) {			       			    	
				        $(xml).find("Model").each(function() {
				        	var name = $(this).find('Name').text();	
				        	var scaPath = $(this).find('Scale');    	
				        	var posPath = $(this).find('Position');				        	
				        	var rotPath = $(this).find('Rotation');
				        	var x, y, z;

				        	var mtlLoader = new THREE.MTLLoader();
				        	mtlLoader.setPath('3DModels/'+name+'/');						
							mtlLoader.load(name+'.mtl', function( materials ){
								materials.preload();
				        		loader = new THREE.OBJLoader();
				        		loader.setMaterials(materials);
			        			loader.setPath('3DModels/'+name+'/');
			        			loader.load(name+'.obj', function ( object ) {
				        			object.castShadow = true;
				        			object.receiveShadow = true;

				        			// Scale
			        				x = parseFloat(scaPath.find('x').text());
			        				y = parseFloat(scaPath.find('y').text());
			        				z = parseFloat(scaPath.find('z').text());
			        				object.scale.set(x,y,z);

			        				// Position
			        				x = parseFloat(posPath.find('x').text());
			        				y = parseFloat(posPath.find('y').text());
			        				z = parseFloat(posPath.find('z').text());
			        				object.position.set(x,y,z);

			        				// Rotation
			        				x = parseFloat(rotPath.find('x').text());
			        				y = parseFloat(rotPath.find('y').text());
			        				z = parseFloat(rotPath.find('z').text());
			        				object.rotation.set(x,y,z);

			        				//shadow
			        				object.traverse( function ( child ) {
									    if ( child instanceof THREE.Mesh ) {
									        child.castShadow = true;
									        child.receiveShadow = true;

									    }

									} );

			        				scene.add(object);
			        				objs.push(object);

			        				console.log(name, "finished loading");
			        			}, function onProgress(xhr){
			        				if(xhr.loaded == 0){
			        					console.log( 'loading', name );
			        				}
			        				else
										console.log( name, (xhr.loaded / xhr.total * 100) + '% loaded' );
								});				        	
				        	});
				        });
				    }
				});
			}

			function onWindowResize() {

				rotatingCamera.aspect = window.innerWidth / window.innerHeight;
				rotatingCamera.updateProjectionMatrix();
				topCamera.aspect = window.innerWidth / window.innerHeight;
				topCamera.updateProjectionMatrix();
				furtherCamera.aspect = window.innerWidth / window.innerHeight;
				furtherCamera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}					

			function animate() {												
				requestAnimationFrame( animate );				
				render();
			}

			function keyManager(event){
				var sens = 0.01
				if(event.keyCode == 32)
					atualCamera = (atualCamera + 1) % 3;
				else if(event.keyCode == 107)
					velocity += sens;
				else if(event.keyCode == 109 && velocity > sens)
					velocity -= sens;
			}

			function lensFlareUpdateCallback( object ) {

				var f, fl = object.lensFlares.length;
				var flare;
				var vecX = -object.positionScreen.x * 2;
				var vecY = -object.positionScreen.y * 2;


				for( f = 0; f < fl; f++ ) {

					flare = object.lensFlares[ f ];

					flare.x = object.positionScreen.x + vecX * flare.distance;
					flare.y = object.positionScreen.y + vecY * flare.distance;

					flare.rotation = 0;

				}

				object.lensFlares[ 2 ].y += 0.025;
				object.lensFlares[ 3 ].rotation = object.positionScreen.x * 0.5 + THREE.Math.degToRad( 45 );

			}
			
			function render() {										
				var delta = clock.getDelta();
				var eTime = clock.getElapsedTime();
				

				//uniforms1.time.value += delta * 5;
				objs[0].rotation.y += 0.03;
				objs[1].rotation.y += 0.1;

				var angle = 0.25 //sets naboo rotation off of the spotlight rotation plane by arctan(angle)
				var angleVariation = Math.cos(velocity * eTime * 0.1); //sets Naboo rotation plane variation overtime
				objs[2].position.x = scene.position.x + 100 * Math.cos(velocity * eTime) * angle * angleVariation;
				objs[2].position.y = scene.position.y + 100 * Math.cos(velocity * eTime);
				objs[2].position.z = scene.position.z + 100 * Math.sin(velocity * eTime);	
				objs[3].position.z = 4 * Math.cos(eTime) + 8;

				spotLight.position.y = scene.position.y + 140 * Math.cos(velocity * eTime * 27.3);
				spotLight.position.z = scene.position.z + 140 * Math.sin(velocity * eTime * 27.3);
				//lensFlare.position.copy(spotLight.position);


				var X = scene.position.x + 20 * Math.cos(0.5 * eTime); 						
				var Y = scene.position.y + 20 * Math.sin(0.5 * eTime);				

				var m4 = new THREE.Matrix4;		
				m4.set(	0, 0, 0, X, 
						0, 0, 0, Y, 
						0, 0, 1, 0, 
						0, 0, 0, 1);
				
				rotatingCamera.position.applyMatrix4(m4);
				rotatingCamera.up.set(0, 0, 1);
				rotatingCamera.lookAt(scene.position);	

				topCamera.up.set(0, 0, 1);
				topCamera.lookAt(scene.position);

				furtherCamera.up.set(0, 0, 1);
				furtherCamera.lookAt(scene.position);

				if (atualCamera == 0){
					renderer.render( scene, rotatingCamera );
				} else if (atualCamera == 1){
					renderer.render( scene, topCamera );
				} else if (atualCamera == 2){
					renderer.render( scene, furtherCamera);
				}
			}

		</script>
	</body>
</html>