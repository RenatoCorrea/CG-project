<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>CG-Project Stormtrooper</title>
	</head>

	<body>
		<script src="http://code.jquery.com/jquery-2.1.3.min.js"></script>
		<script src="js/three.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/MTLLoader.js"></script>
		<script src="js/Detector.js"></script>

		<script id="vs_BB8" type="x-shader/x-vertex">
		    varying vec2 vUv;
			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

		<script id="fs_BB8" type="x-shader/x-fragment">
	        uniform float time;
			uniform vec2 resolution;
			varying vec2 vUv;
			void main( void ) {
				vec2 position = -1.0 + 2.0 * vUv;
				float red = abs( sin( position.x * position.y + time / 5.0 ) );
				float green = abs( sin( position.x * position.y + time / 4.0 ) );
				float blue = abs( sin( position.x * position.y + time / 3.0 ) );
				gl_FragColor = vec4( red, green, blue, 1.0 );
			}
    	</script>

		<script>
			var cameraRotate, cameraTop, cameraFurther, cameraSide, scene, renderer;
			var plane;
			var container;
			var clock = new THREE.Clock();
			var uniforms;			
			var atualCamera = 0;			
			objs = [];

			if (Detector.webgl) {
    			init();
    			loadObjs();
    			animate();
			} else {
			    var warning = Detector.getWebGLErrorMessage();
			    document.getElementById('container').appendChild(warning);
			}
			
			function init(){
				container = document.createElement('div');
				document.body.appendChild(container);


				//Scene
				scene = new THREE.Scene();

				//Renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFShadowMap;  // options are THREE.BasicShadowMap | THREE.PCFShadowMap | THREE.PCFSoftShadowMap
				container.appendChild( renderer.domElement );

				//Planet ground
				planetRadius = 100; //set main planet radius
				var loader = new THREE.TextureLoader();
				var groundTexture = loader.load( 'Textures/grasslight-big.jpg' );
				groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
				groundTexture.repeat.set( 1500, 1500);
				groundTexture.anisotropy = 16;
				var groundMaterial = new THREE.MeshPhongMaterial( { color: 0x909090, specular: 0x111111, map: groundTexture } );
				var mesh = new THREE.Mesh( new THREE.SphereGeometry( planetRadius, 64, 32 )/*new THREE.SphereGeometry(30, 16, 8)*/, groundMaterial );
				mesh.receiveShadow = true;
				mesh.castShadow = true;
				scene.add( mesh );



				//ambient light
				var ambient = new THREE.AmbientLight(0x101010);
				scene.add( ambient );

				//spotLight - Sun
				spotLight = new THREE.SpotLight( 0xffffff, 2 );
				spotLight.position.set(0, 0, 0);
				//Shadows
				spotLight.castShadow = true;
				spotLight.penumbra = 0.05;
				spotLight.decay = 0.8;
				spotLight.distance = 500;
				spotLight.shadow.mapSize.width = 1024*4;
				spotLight.shadow.mapSize.height = 1024*4;
				spotLight.shadow.camera.near = 1;
				spotLight.shadow.camera.far = 500;
				scene.add(spotLight);

				//Sun sphere
				var sphere = new THREE.SphereGeometry( 10, 16, 8 );
				spotLight.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xfff16c } ) ) );;

				/*
				// Used in shaders
				uniforms1 = {
					time:       { value: 1.0 },
					resolution: { value: new THREE.Vector2() }
				};			
				
				//obj file - load BB8
				loader = new THREE.OBJLoader(); 
				loader.load('3DModels/BB8/BB8.obj',	function ( object ) {

						var bb8Material = new THREE.ShaderMaterial({								
							uniforms : uniforms1,
				   			vertexShader: document.getElementById('vs_BB8').innerHTML,
				   			fragmentShader: document.getElementById('fs_BB8').innerHTML
						});	

						object.traverse( function ( child ) {
				        	if ( child instanceof THREE.Mesh ) {				        		
				            	child.material = bb8Material;
				        	}				        	
				    	});
			  						  		
				  		object.scale.set(0.01, 0.01, 0.01);
				  		object.position.set(-3, 0, 0);
				  		object.rotation.x = -80;
			      		scene.add( object );
			      		obj_bb8 = object;
				});*/			

				//Rotating Camera
				cameraRotate = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 + planetRadius * 2 );
				cameraRotate.position.set(0, -10, 3 + planetRadius);

				//Top Camera
				cameraTop = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 + planetRadius * 2);
				cameraTop.position.set(0, 4, 200+planetRadius);

				//Further Camera
				cameraFurther = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 + planetRadius * 2);
				cameraFurther.position.set(0, -(100+planetRadius), 3+planetRadius);

				//Side Camera
				cameraSide = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 + planetRadius * 2);
				cameraSide.position.set(-(100+planetRadius)-100, 0, 0);
				
				window.addEventListener( 'resize', onWindowResize, false );				
				window.addEventListener( 'keydown', keyManager );

				

			}

			function loadObjs() {	
				$.ajax({
				    type: "GET",
				    url: "Config/Models.xml",
				    dataType: "xml",
				    cache: false,
				    async: false,
				    success: function (xml) {			       			    	
				        $(xml).find("Model").each(function() {
				        	var name = $(this).find('Name').text();	
				        	var scaPath = $(this).find('Scale');    	
				        	var posPath = $(this).find('Position');				        	
				        	var rotPath = $(this).find('Rotation');
				        	var x, y, z;

				        	var mtlLoader = new THREE.MTLLoader();
				        	mtlLoader.setPath('3DModels/'+name+'/');						
							mtlLoader.load(name+'.mtl', function( materials ){
								materials.preload();
				        		loader = new THREE.OBJLoader();
				        		loader.setMaterials(materials);
			        			loader.setPath('3DModels/'+name+'/');
			        			loader.load(name+'.obj', function ( object ) {
				        			object.castShadow = true;
				        			object.receiveShadow = true;

				        			// Scale
			        				x = parseFloat(scaPath.find('x').text());
			        				y = parseFloat(scaPath.find('y').text());
			        				z = parseFloat(scaPath.find('z').text());
			        				object.scale.set(x,y,z);

			        				// Position
			        				x = parseFloat(posPath.find('x').text());
			        				y = parseFloat(posPath.find('y').text());
			        				z = parseFloat(posPath.find('z').text());
			        				object.position.set(x,y,z+planetRadius);

			        				// Rotation
			        				x = parseFloat(rotPath.find('x').text());
			        				y = parseFloat(rotPath.find('y').text());
			        				z = parseFloat(rotPath.find('z').text());
			        				object.rotation.set(x,y,z);

			        				//shadow
			        				object.traverse( function ( child ) {
									    if ( child instanceof THREE.Mesh ) {
									        child.castShadow = true;
									        child.receiveShadow = true;

									    }

									} );

			        				scene.add(object);
			        				objs.push(object);
			        			});				        	
				        	});
				        });
				    }
				});
			}

			function onWindowResize() {

				cameraRotate.aspect = window.innerWidth / window.innerHeight;
				cameraRotate.updateProjectionMatrix();
				cameraFurther.aspect = window.innerWidth / window.innerHeight;
				cameraFurther.updateProjectionMatrix();
				cameraTop.aspect = window.innerWidth / window.innerHeight;
				cameraTop.updateProjectionMatrix();
				cameraSide.aspect = window.innerWidth / window.innerHeight;
				cameraSide.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}					

			function animate() {												
				requestAnimationFrame( animate );				
				render();
			}

			function keyManager(event){
				if(event.keyCode == 32)
					atualCamera = (atualCamera + 1) % 4;							
			}
			
			function render() {										
				var delta = clock.getDelta();
				var eTime = clock.getElapsedTime();
				var velocity = 0.05; // set general rotation velocity

				//uniforms1.time.value += delta * 5;
				//Stormtrooper
				objs[0].rotation.y += 0.03;
				//BB8
				objs[1].rotation.y += 0.1;

				//Naboo rotation
				var angle = 0.25 //sets naboo rotation off of the spotlight rotation plane by arctan(angle)
				var angleVariation = Math.cos(velocity * eTime * 0.1); //sets Naboo rotation plane variation overtime
				objs[2].position.x = scene.position.x + (80+planetRadius) * Math.cos(velocity * eTime) * angle * angleVariation;
				objs[2].position.y = scene.position.y + (80+planetRadius) * Math.cos(velocity * eTime);
				objs[2].position.z = scene.position.z + (80+planetRadius) * Math.sin(velocity * eTime);	

				//Arc170
				objs[3].position.z = planetRadius + 4 * Math.cos(eTime) + 8;

				spotLight.position.y = scene.position.y + (planetRadius + 150) * Math.cos(velocity * eTime * 27.3);
				spotLight.position.z = scene.position.z + (planetRadius + 150) * Math.sin(velocity * eTime * 27.3);
				spotLight.lookAt(scene.position);


				var X = scene.position.x + 20 * Math.cos(0.5 * eTime); 						
				var Y = scene.position.y + 20 * Math.sin(0.5 * eTime);				

				var m4 = new THREE.Matrix4;		
				m4.set(	0, 0, 0, X, 
						0, 0, 0, Y, 
						0, 0, 1, 0, 
						0, 0, 0, 1);				
				
				cameraRotate.position.applyMatrix4(m4);
				cameraRotate.up.set(0, 0, 1);
				cameraRotate.lookAt(new THREE.Vector3(scene.position.x, scene.position.y, planetRadius));	

				cameraTop.up.set(0, 0, 1);
				cameraTop.lookAt(scene.position);

				cameraFurther.up.set(0, 0, 1);
				cameraFurther.lookAt(scene.position);

				cameraSide.up.set(0, 0, 1);
				cameraSide.lookAt(scene.position);

				if (atualCamera == 0){
					renderer.render( scene, cameraRotate );
				} else if (atualCamera == 1){
					renderer.render( scene, cameraTop );
				} else if (atualCamera == 2){
					renderer.render( scene, cameraFurther);
				} else if (atualCamera == 3){
					renderer.render( scene, cameraSide);
				}
			}

		</script>
	</body>
</html>